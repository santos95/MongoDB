//AGGREGATION FRAMEWORK 
//MORE POWER TO RETRIEVE DATA
//COMPLEX TRANFORMATION TO THE DATA -- PROVIDE COMPLEX DATA TRANSFORMATION CAPABILITIES 
//ALLOW TO RETRIEVE DATA IN THE EXACT FORMAT THAT IS NEEDED 

// AGGREGATION FRAMEWORK ALTERNATIVE TO THE FIND METHOD 

// BUILDING A PIPELINE OF STEPS THAT RUNS ON TE DATA THAT IS RETRIEVED FROM THE COLLECTION
// AND THEN GIVES THE OUTPUT IN THE FORM THAT IS NEEDED 

// STAGES -- WE CAN HAVE MANY STAGES 

// COLLECTION -> $match -> $group -> $project -> $sort -> output  (list of documents)

//WE CAN USE AND COMBINE STAGES AS WE NEED - POWERFUL WAY OF MODELING DATA TRANSFORMATION

// A STRUCTURED WAY OF HAVING SOME INPUT DATA AND THE SLOWLY MODIFYING IT AS WE NEED 

// AGGREGATION PIPELINE IS ONE OR MORE STAGES THAT PROCESS DOCUMENTS 

//EACH STEP PERFROMS AND OPERATION ON THE INPUT DATA - FILTER, GROUP, CALCULATE VALUES 
//THE OUTPUT OF ONE IS THE INPUT OF OTHER STAGE 
//CAN RETURN RESULTS FOR A GROUP OF DOCUEMNTS 


use('pizza')
db.orders.findOne()

// orders quantity - Pizza Pepperoni 
use('pizza')
db.orders.aggregate([{
    $match: {name: "Pepperoni"}

  },
  {
    $group: {
      _id: "$name",
      totalQuantity: {$sum: "$quantity"}
    }
  }])

  use("pizza")
  db.orders.aggregate([
    {
      $match: {size: "medium"}
    },
    {
      $group: {
        _id: "$name",
        totalQuantity: {$sum: "$quantity"}
      } 
    }
  ])

  // Calculate Total Order Value and Average Order Quantity
  use("pizza")
  db.orders.aggregate([
    {
      $match: {date: {$gt: new ISODate("2020-01-30"), $lt: new ISODate("2022-01-30")}}
    },
    {
      $group: {
        _id: "$name", 
        totalQuantity: {$sum: "$quantity"},
        totalOrderValue: {$sum: {$multiply: ["$price", "$quantity"]}},
        averageOrderQuantity: {$avg: "$quantity"}
      }
    }, 
    {
      $sort: {totalOrderValue: -1}
    }
  ])

//---------------------------------------------------------------------------

  use('personsAnalytics')
  db.personsData.findOne()

 //requiere an array - represent the series of steps - aggregation pipeline
 //the first step - receive the entire data from the collection 
 //run on the server - can take advantage of indexes 
 //the next step perform operations on the data from the previous step
 //match is used to filter data - as we filter in find() - also we can filter in 
 //way that allow us to take advantage of indexes
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $match: {gender: "female"}
    }
  ])

  //agregate returns a cursor
  //$match to filter in the same way as the find method 


  //GROUP STAGE [
  // ALLOWS TO GROUP THE DATA BY CERTAIN FIELD OR 
  // BY MULTIPLE FIELDS 
// REQUIERES THE PARAMETERS: 
//_id: the fields in which the data will be grouped - defines which fields we want to group - value a document
//field: calculated field - one or more calculated fields - use aggregation functions 
//
-id : 
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $match: {gender: "female"}
    },
    {
      $group: {
        _id: {state: "$location.state"},
        totalPersons: {$sum: 1}
      }
    },
    {
      $sort: {totalPersons: -1}
    }
  ])

  use('personsAnalytics')
db.personsData.find({gender: "female", "location.state": "midtjylland"}).count() //33



//agregation functions or accumulators operators 

  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $group: {_id: null, 
      total: {$sum: 1}}
    },
    {
      $project: { _id: 0,
      total: 1}
    }
  ])

//totals personas by gender 
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $group: {
        _id: "$gender",
        totalPersons: {$sum: 1}
      }
    }, 
    {
      $project: {
        _id: 1,
        totalPersons: 1,
        total: {$sum: ["$totalPersons"] }
      }
    }
  ])

    use('personsAnalytics')
  db.personsData.aggregate([
    {
      $group: {
        _id: "$gender",
        totalPersons: {$sum: 1}
      }
    }, 
    {
      $group: {
        _id: {"_id.gender", "totalPersons"},
        total: {$sum: "$_id.totalPersons"}
      }
    }
  ])

//$sort 
// we can sort in any place 
// sort for totalPersons 
// if we sort in after the match state - sort persons data not the aggregated data 
// we can sort after the group the get an sorted result 
use('personsAnalytics')
db.personsData.aggregate([
  {
    $match: {gender: "female"}
  }, 
  {
    $group: {
      _id: {state: "$location.state"},
      totalPersons: {$sum: 1}
    }
  },
  {
    $sort: {
      totalPersons: -1 //descending 
    }
  }
])

///this sort stage access to the grouped data from the group stage 
//not work over the original data fetched from the collection 
//process the output of the previous stage 
//with the aggregation pipeline we can process the data in a way that is not possible in find()
//we group and then sort the data on the grouped data 
//in the result of the group state 

//project
//allows to transform every single document - input n documents - output n documents 
//group: input n documents - output m documents based on the fields in which the data is grouped
//project allows to create new fields based on the input documents
//prooject:  include, exclude data - create new fields with hardcoded values or derivated fields 
//$project: {}
//allows to control which fields to output as result 
    use('personsAnalytics')
    db.personsData.findOne()
    db.personsData.aggregate([
      {
        $project: {
          _id: 0, 
          gender: 1,
          fullName: {$concat: ["hello", "world"]}  //can work with hardcoded data
         }
      }
      ])

 use('personsAnalytics')
 db.personsData.aggregate([
      {
        $project: {
          _id: 0, 
          gender: 1,
          fullName: {$concat: ["$name.first", " ", "$name.last"]}  
         }
      }
      ])


   use('personsAnalytics')
 db.personsData.aggregate([
      {
        $project: {
          _id: 0, 
          gender: 1,
          fullName: {$concat: [
            {$toUpper: "$name.first"}, //to upper all the field value
            " ", 
           {$toUpper: "$name.last"}]}  
         }
      }
      ])

use('personsAnalytics')
db.personsData.aggregate(
  [
    {
      $project: {
        _id: 0,
        gender: 1,
        fullName: {
          $concat: [
            {$toUpper: {$substrCP: ['$name.first', 0, 1]}}, 
            {$substrCP: ['$name.first', 1, {$subtract: [{$strLenCP:"$name.first"}, 1]}]},
            ' ',
            {$toUpper: {$substrCP: ['$name.last', 0, 1]}},
            {$substrCP: ['$name.last', 1, {$subtract: [{$strLenCP: '$name.last'}, 1]}]}
          ]
        }
      }
    }
  ])

  
use('personsAnalytics')
db.personsData.aggregate(
  [
    {
      $match: {gender: "female"}
    },
    {
      $project: {
        _id: 0,
        gender: 1,
        fullName: {
          $concat: [
            {$toUpper: {$substrCP: ['$name.first', 0, 1]}}, 
            {$substrCP: ['$name.first', 1, {$subtract: [{$strLenCP:"$name.first"}, 1]}]},
            ' ',
            {$toUpper: {$substrCP: ['$name.last', 0, 1]}},
            {$substrCP: ['$name.last', 1, {$subtract: [{$strLenCP: '$name.last'}, 1]}]}
          ]
        }
      }
    }
  ])

// $substrCP -- to extract an substring from a string 
// // three parameters ['stringValue', start, end]
// $toUpper: {string} 
// $strLenCP - to get the len of a string 
use('personsAnalytics')
db.personsData.findOne()


use('personsAnalytics')
db.personsData.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      email: 1,
      age: "$dob.age",
      birthdate: {ISODate: "$dob.date"},
      birthdate1: {$convert: {
        input: "$dob.date", 
        to: "date"}},
      birthdate2: {
        $toDate: "$dob.date"
      },
      location:{type: "Point", coordinates: [
        {$convert: {
          input: "$location.coordinates.longitude", 
          to: "double", 
          onError: 0, 
          onNull: 0}}, 
        {$convert: {
          input: "$location.coordinates.latitude", 
          to: "double", 
          onError: 0, 
          onNull: 0}}
      ]}},
  }, 
  {
    $project: {
      fullName: {
        $concat: [
          {$toUpper: {$substrCP: ["$name.first", 0, 1]}},
          {$substrCP: ["$name.first", 1, {$subtract: [{$strLenCP: "$name.first"}, 1]}]},
          " ",
          {$toUpper: {$substrCP: ["$name.last", 0, 1]}},
          {$substrCP: ["$name.last", 1, {$subtract: [{$strLenCP: "$name.last"}, 1]}]}
        ]
      },
      age: 1,
      birthdate: 1,
      birthdate1: 1,
      birthdate2: 1,
      email: 1,
      location: 1
    }
  }
])

//chortcuts _ toDate instead of convert - use convert when you know that you can have nulls 
//convert -- allow to do some data cleaning - define values on errors o nulls

// "$name.first" indicates to mongo that is not hardcoded - refers to a field in the input documents
// --indicates to mongo to takes the value of the field 


//group the result of projections 

use('personsAnalytics')

db.personsData.aggregate([
  {
    $project: {
      _id: 0,
      birthdate: {$toDate: "$dob.date"}
    }
  },
  {
    $group: {
      _id: {birthYear: {$isoWeekYear: "$birthdate"}},
      totalPersons: {$sum: 1}
    }
  },
  {
    $sort: {totalPersons: -1}
  }
])


//group vs project 
//group - grouping multiple documents into 1 
//project - 1 to 1 relation - input one document output one 
//group - group date base on some field - categories + some calculated field 
//aggregation, calculation, statistic, summary 
//tranformation to summarize or group data in documents 
//generates documents with sumarize data based on the input documentes 
//projection - exclude, include, rename, transform a single document, add fields and so on 
//get n documents and output n transformed documents 



/// WORKING WITH ARRAYS 
use ('arraysDb')
db.friends.findOne()

//two ways of group 
use ('arraysDb')
db.friends.aggregate([
  {
    $group: {
      _id: "age",
      total: {$sum: 1}
    }
  }
])

//in this way is more cleare 
use ('arraysDb')
db.friends.aggregate([
  {
    $group: {
      _id: {age: "age"},
      total: {$sum: 1}
    }
  }
])

//to combine array values 
//this is a way to handle multiple array values in one array 
//$push - to push a new element to a new array for every incoming document 

//to push hobbies in the new array 
use('arraysDb')
db.friends.aggregate([
  {
    $group: {
      _id: {age: '$age'},
      allHobbies: {$push: '$hobbies'}
    }
  }
])

//for group age - push an array corresponding to hobbies field into allHobbies field 

//$unwind - to pull out elements of one array 
//flattens the array by repeating the document that held the array as often as needed to merge 
//it with the array elements 
//unwind - takes one document and spits out multiple documents 

use('arraysDb')
db.friends.aggregate([
  {
    /**
     * path: Path to the array field.
     * includeArrayIndex: Optional name for index.
     * preserveNullAndEmptyArrays: Optional
     *   toggle to unwind null and empty values.
     */
    $unwind: '$hobbies'
  }
])

//creates an array with the elements corresponding to the hobbies array
//generate duplicates values 
use('arraysDb')
db.friends.aggregate([
  {
    $unwind: '$hobbies'
  }, 
  {
    $group: {
      _id: {age: '$age'},
      allHobbies: {$push: '$hobbies'}
    }
  }, 
  {
    $sort: {_id: 1}
  }
])


//$addToSet - push and avoids duplicate values 
//if finds an entry that exists - is not pushed as a new value into the array 
//DO THE SAME AS $push but avoid duplicate values 
use('arraysDb')
db.friends.aggregate([
  {
    $unwind: '$hobbies'
  },
  {
    $group: {
      _id: {age: '$age'},
      allHobbies: {$addToSet: '$hobbies'}
    }
  },
  {
    $sort: {_id: 1}
  }
])


//PROJECTIONS WITH ARRAYS 
//slice: allows to get back an slice of an array 
//slice: {array, 1} array and the number of elements to get from the array 
//slice: {array, 0, 1} -starts on position 1 and get one element - get the first 
use('arraysDb')
db.friends.findOne()

use('arraysDb')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", 1]} }
  }])

  
use('arraysDb')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", -1]} } //to get the last element 
  }])

  
use('arraysDb')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", -2]} } //to get the last two elements

  }])

//works with indexes for arrays - start 0  
//array of 3 elements - index 0, 1,2
  
use('arraysDb')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", 0, 1]} } //to get the last two elements

  }])

  //len 
  //how many exams - 3 get the size of the examScores array for every document 
  use('arraysDb')
  db.friends.aggregate([
    {
      $project: {
        _id: 0,
        numScores: {$size: "$examScores"} //get the size of an array 
      }
    }
  ])

//see scores greater than 60
//filter: filter out elements of one array
//only return values that fulfill the condition 
use('arraysDb')
db.friends.aggregate([
  {
    $project: {
      _id: 0,
      scores: {
        $filter: {input: '$examScores', as: 'sc', cond: {$gt:['$$sc.score', 60] } //the as is called local varibles
      }
    } 
  }
  }
  //as is the name of the local variables that will store every value corresponding to the examScores array 
  //to access the values of sc variables we use $$
])

//with filter we only get scores greater than 60 