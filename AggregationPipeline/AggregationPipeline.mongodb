//AGGREGATION FRAMEWORK 
//MORE POWER TO RETRIEVE DATA
//COMPLEX TRANFORMATION TO THE DATA -- PROVIDE COMPLEX DATA TRANSFORMATION CAPABILITIES 
//ALLOW TO RETRIEVE DATA IN THE EXACT FORMAT THAT IS NEEDED 

// AGGREGATION FRAMEWORK ALTERNATIVE TO THE FIND METHOD 

// BUILDING A PIPELINE OF STEPS THAT RUNS ON TE DATA THAT IS RETRIEVED FROM THE COLLECTION
// AND THEN GIVES THE OUTPUT IN THE FORM THAT IS NEEDED 

// STAGES -- WE CAN HAVE MANY STAGES 

// COLLECTION -> $match -> $group -> $project -> $sort -> output  (list of documents)

//WE CAN USE AND COMBINE STAGES AS WE NEED - POWERFUL WAY OF MODELING DATA TRANSFORMATION

// A STRUCTURED WAY OF HAVING SOME INPUT DATA AND THE SLOWLY MODIFYING IT AS WE NEED 

// AGGREGATION PIPELINE IS ONE OR MORE STAGES THAT PROCESS DOCUMENTS 

//EACH STEP PERFROMS AND OPERATION ON THE INPUT DATA - FILTER, GROUP, CALCULATE VALUES 
//THE OUTPUT OF ONE IS THE INPUT OF OTHER STAGE 
//CAN RETURN RESULTS FOR A GROUP OF DOCUEMNTS 


use('pizza')
db.orders.findOne()

// orders quantity - Pizza Pepperoni 
use('pizza')
db.orders.aggregate([{
    $match: {name: "Pepperoni"}

  },
  {
    $group: {
      _id: "$name",
      totalQuantity: {$sum: "$quantity"}
    }
  }])

  use("pizza")
  db.orders.aggregate([
    {
      $match: {size: "medium"}
    },
    {
      $group: {
        _id: "$name",
        totalQuantity: {$sum: "$quantity"}
      } 
    }
  ])

  // Calculate Total Order Value and Average Order Quantity
  use("pizza")
  db.orders.aggregate([
    {
      $match: {date: {$gt: new ISODate("2020-01-30"), $lt: new ISODate("2022-01-30")}}
    },
    {
      $group: {
        _id: "$name", 
        totalQuantity: {$sum: "$quantity"},
        totalOrderValue: {$sum: {$multiply: ["$price", "$quantity"]}},
        averageOrderQuantity: {$avg: "$quantity"}
      }
    }, 
    {
      $sort: {totalOrderValue: -1}
    }
  ])

//---------------------------------------------------------------------------
//import 
//mongoimport persons.json -d personsAnalytics -c personsData --jsonArray

  use('personsAnalytics')
  db.personsData.findOne()

 //requiere an array - represent the series of steps - aggregation pipeline
 //the first step - receive the entire data from the collection 
 //run on the server - can take advantage of indexes 
 //the next step perform operations on the data from the previous step
 //match is used to filter data - as we filter in find() - also we can filter in 
 //way that allow us to take advantage of indexes
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $match: {gender: "female"}
    }
  ])

  //agregate returns a cursor
  //$match to filter in the same way as the find method 


  //GROUP STAGE [
  // ALLOWS TO GROUP THE DATA BY CERTAIN FIELD OR 
  // BY MULTIPLE FIELDS 
// REQUIERES THE PARAMETERS: 
//_id: the fields in which the data will be grouped - defines which fields we want to group - value a document
//field: calculated field - one or more calculated fields - use aggregation functions 
//
-id : 
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $match: {gender: "female"}
    },
    {
      $group: {
        _id: {state: "$location.state"},
        totalPersons: {$sum: 1}
      }
    },
    {
      $sort: {totalPersons: -1}
    }
  ])

  use('personsAnalytics')
db.personsData.find({gender: "female", "location.state": "midtjylland"}).count() //33



//agregation functions or accumulators operators 

  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $group: {_id: null, 
      total: {$sum: 1}}
    },
    {
      $project: { _id: 0,
      total: 1}
    }
  ])

//totals personas by gender 
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      $group: {
        _id: "$gender",
        totalPersons: {$sum: 1}
      }
    }, 
    {
      $project: {
        _id: 1,
        totalPersons: 1,
        total: {$sum: ["$totalPersons"] }
      }
    }
  ])

    use('personsAnalytics')
  db.personsData.aggregate([
    {
      $group: {
        _id: "$gender",
        totalPersons: {$sum: 1}
      }
    }, 
    {
      $group: {
        _id: {"_id.gender", "totalPersons"},
        total: {$sum: "$_id.totalPersons"}
      }
    }
  ])

//$sort 
// we can sort in any place 
// sort for totalPersons 
// if we sort in after the match state - sort persons data not the aggregated data 
// we can sort after the group the get an sorted result 
use('personsAnalytics')
db.personsData.aggregate([
  {
    $match: {gender: "female"}
  }, 
  {
    $group: {
      _id: {state: "$location.state"},
      totalPersons: {$sum: 1}
    }
  },
  {
    $sort: {
      totalPersons: -1 //descending 
    }
  }
])

///this sort stage access to the grouped data from the group stage 
//not work over the original data fetched from the collection 
//process the output of the previous stage 
//with the aggregation pipeline we can process the data in a way that is not possible in find()
//we group and then sort the data on the grouped data 
//in the result of the group state 

//project
//allows to transform every single document - input n documents - output n documents 
//group: input n documents - output m documents based on the fields in which the data is grouped
//project allows to create new fields based on the input documents
//prooject:  include, exclude data - create new fields with hardcoded values or derivated fields 
//$project: {}
//allows to control which fields to output as result 
    use('personsAnalytics')
    db.personsData.findOne()
    db.personsData.aggregate([
      {
        $project: {
          _id: 0, 
          gender: 1,
          fullName: {$concat: ["hello", "world"]}  //can work with hardcoded data
         }
      }
      ])

 use('personsAnalytics')
 db.personsData.aggregate([
      {
        $project: {
          _id: 0, 
          gender: 1,
          fullName: {$concat: ["$name.first", " ", "$name.last"]}  
         }
      }
      ])


   use('personsAnalytics')
 db.personsData.aggregate([
      {
        $project: {
          _id: 0, 
          gender: 1,
          fullName: {$concat: [
            {$toUpper: "$name.first"}, //to upper all the field value
            " ", 
           {$toUpper: "$name.last"}]}  
         }
      }
      ])

use('personsAnalytics')
db.personsData.aggregate(
  [
    {
      $project: {
        _id: 0,
        gender: 1,
        fullName: {
          $concat: [
            {$toUpper: {$substrCP: ['$name.first', 0, 1]}}, 
            {$substrCP: ['$name.first', 1, {$subtract: [{$strLenCP:"$name.first"}, 1]}]},
            ' ',
            {$toUpper: {$substrCP: ['$name.last', 0, 1]}},
            {$substrCP: ['$name.last', 1, {$subtract: [{$strLenCP: '$name.last'}, 1]}]}
          ]
        }
      }
    }
  ])

  
use('personsAnalytics')
db.personsData.aggregate(
  [
    {
      $match: {gender: "female"}
    },
    {
      $project: {
        _id: 0,
        gender: 1,
        fullName: {
          $concat: [
            {$toUpper: {$substrCP: ['$name.first', 0, 1]}}, 
            {$substrCP: ['$name.first', 1, {$subtract: [{$strLenCP:"$name.first"}, 1]}]},
            ' ',
            {$toUpper: {$substrCP: ['$name.last', 0, 1]}},
            {$substrCP: ['$name.last', 1, {$subtract: [{$strLenCP: '$name.last'}, 1]}]}
          ]
        }
      }
    }
  ])

// $substrCP -- to extract an substring from a string 
// // three parameters ['stringValue', start, end]
// $toUpper: {string} 
// $strLenCP - to get the len of a string 
use('personsAnalytics')
db.personsData.findOne()


use('personsAnalytics')
db.personsData.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      email: 1,
      age: "$dob.age",
      birthdate: {ISODate: "$dob.date"},
      birthdate1: {$convert: {
        input: "$dob.date", 
        to: "date"}},
      birthdate2: {
        $toDate: "$dob.date"
      },
      location:{type: "Point", coordinates: [
        {$convert: {
          input: "$location.coordinates.longitude", 
          to: "double", 
          onError: 0, 
          onNull: 0}}, 
        {$convert: {
          input: "$location.coordinates.latitude", 
          to: "double", 
          onError: 0, 
          onNull: 0}}
      ]}},
  }, 
  {
    $project: {
      fullName: {
        $concat: [
          {$toUpper: {$substrCP: ["$name.first", 0, 1]}},
          {$substrCP: ["$name.first", 1, {$subtract: [{$strLenCP: "$name.first"}, 1]}]},
          " ",
          {$toUpper: {$substrCP: ["$name.last", 0, 1]}},
          {$substrCP: ["$name.last", 1, {$subtract: [{$strLenCP: "$name.last"}, 1]}]}
        ]
      },
      age: 1,
      birthdate: 1,
      birthdate1: 1,
      birthdate2: 1,
      email: 1,
      location: 1
    }
  }
])

//chortcuts _ toDate instead of convert - use convert when you know that you can have nulls 
//convert -- allow to do some data cleaning - define values on errors o nulls

// "$name.first" indicates to mongo that is not hardcoded - refers to a field in the input documents
// --indicates to mongo to takes the value of the field 


//group the result of projections 

use('personsAnalytics')

db.personsData.aggregate([
  {
    $project: {
      _id: 0,
      birthdate: {$toDate: "$dob.date"}
    }
  },
  {
    $group: {
      _id: {birthYear: {$isoWeekYear: "$birthdate"}},
      totalPersons: {$sum: 1}
    }
  },
  {
    $sort: {totalPersons: -1}
  }
])


//group vs project 
//group - grouping multiple documents into 1 
//project - 1 to 1 relation - input one document output one 
//group - group date base on some field - categories + some calculated field 
//aggregation, calculation, statistic, summary 
//tranformation to summarize or group data in documents 
//generates documents with sumarize data based on the input documentes 
//projection - exclude, include, rename, transform a single document, add fields and so on 
//get n documents and output n transformed documents 



/// WORKING WITH ARRAYS 

//import 
//mongoimport array-data.json -d arraysDB -c friends --jsonArray

use ('arraysDB')
db.friends.findOne()

//two ways of group 
use ('arraysDB')
db.friends.aggregate([
  {
    $group: {
      _id: "age",
      total: {$sum: 1}
    }
  }
])

//in this way is more clear
use ('arraysDB')
db.friends.aggregate([
  {
    $group: {
      _id: {age: "age"},
      total: {$sum: 1}
    }
  }
])

//to combine array values 
//this is a way to handle multiple array values in one array 
//$push - to push a new element to a new array for every incoming document 

//to push hobbies in the new array 
use('arraysDB')
db.friends.aggregate([
  {
    $group: {
      _id: {age: '$age'},
      allHobbies: {$push: '$hobbies'}
    }
  }
])

//for group age - push an array corresponding to hobbies field into allHobbies field 

//$unwind - to pull out elements of one array 
//flattens the array by repeating the document that held the array as often as needed to merge 
//it with the array elements 
//unwind - takes one document and spits out multiple documents 

use('arraysDB')
db.friends.aggregate([
  {
    /**
     * path: Path to the array field.
     * includeArrayIndex: Optional name for index.
     * preserveNullAndEmptyArrays: Optional
     *   toggle to unwind null and empty values.
     */
    $unwind: '$hobbies'
  }
])

//creates an array with the elements corresponding to the hobbies array
//generate duplicates values 
use('arraysDB')
db.friends.aggregate([
  {
    $unwind: '$hobbies'
  }, 
  {
    $group: {
      _id: {age: '$age'},
      allHobbies: {$push: '$hobbies'}
    }
  }, 
  {
    $sort: {_id: 1}
  }
])


//$addToSet - push and avoids duplicate values 
//if finds an entry that exists - is not pushed as a new value into the array 
//DO THE SAME AS $push but avoid duplicate values 
use('arraysDB')
db.friends.aggregate([
  {
    $unwind: '$hobbies'
  },
  {
    $group: {
      _id: {age: '$age'},
      allHobbies: {$addToSet: '$hobbies'}
    }
  },
  {
    $sort: {_id: 1}
  }
])

//with unwind, push and addtoSet - powerful features to manage array data efficiently
//and transform it into the required format 

//PROJECTIONS WITH ARRAYS 
//slice: allows to get back an slice of an array 
//slice: {array, 1} array and the number of elements to get from the array 
//slice: {array, 0, 1} -starts on position 1 and get one element - get the first 
use('arraysDB')
db.friends.findOne()

use('arraysDB')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", 1]} }
  }])


  
use('arraysDB')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", -1]} } //to get the last element 
  }])

  
use('arraysDB')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", -2]} } //to get the last two elements

  }])

//works with indexes for arrays - start 0  
//array of 3 elements - index 0, 1,2
  
use('arraysDB')
db.friends.aggregate([
  {
    $project: {_id: 0, 
    examScores: {$slice: ["$examScores", 0, 1]} } //to get the last two elements

  }])

  //len 
  //how many exams - 3 get the size of the examScores array for every document 
  
use('arraysDB')
  db.friends.aggregate([
    {
      $project: {
        _id: 0,
        numScores: {$size: "$examScores"} //get the size of an array 
      }
    }
  ])

//see scores greater than 60
//filter: filter out elements of one array
//only return values that fulfill the condition 
use('arraysDB')
db.friends.aggregate([
  {
    $project: {
      _id: 0,
      scores: {
        $filter: {input: '$examScores', as: 'sc', cond: {$gt:['$$sc.score', 60] } //the as is called local varibles
      }
    } 
  }
  }
  //as is the name of the local variables that will store every value corresponding to the examScores array 
  //to access the values of sc variables we use $$
])

//

//with filter we only get scores greater than 60 

use('arraysDB')
db.friends.findOne()

db.friends.aggregate([
  {
    $group: {
      _id: {
        age: "$age"
      },
      allHobbies: {
        $push: "$hobbies"
      }
    }
  }
])

//WITH $filter we can filter arrays in documents into the project phase 

use('arraysDB')
db.friends.findOne()

//get the top score for every friend object 
use('arraysDB')
db.friends.aggregate([
  {
    $unwind: "$examScores"
  },
  {
    $group: {
      _id: '$_id',
      name: {$first: "$name"},
      maxScore: {$max: "$examScores.score"}
    }
  },
  {
    $sort: {
      maxScore: -1
    }
  }
])

//getting the max score per friend using $first 
use('arraysDB')
db.friends.aggregate([
  {
    $unwind: "$examScores"
  }, 
  {
    $sort: {"examScores.score": -1}
  },
  {
    $project: {
      name: 1,
      score: "$examScores.score"
    }
  },
  {
    $group: {
      _id: "$_id",
      name: {$first: "$name"},
      maxScore: {$first: "$score"}
    }
  }
])
//get masScore for any friend group by id, name and age

use('arraysDB')
db.friends.aggregate([
  {
    $unwind: "$examScores"
  },
  {
    $group: {
      _id: "$_id",
      name: {$first: "$name"},
      age: {$first: "$age"},
      maxScore: {$max: "$examScores.score"}
    }
  },
  {
    $sort: {maxScore: -1}
  }
  ])

  /////////////////////////////////////////////////////////////////
  ///$bucket
  //categorize incoming documents into groups - called buckets 
  //this groups are based on expressions - boundaries 
  //output - one document per bucket or group 
  use('personsAnalytics')
  db.personsData.findOne()

  use('personsAnalytics')
  db.personsData.aggregate([
    {
      /**
       * groupBy: The expression to group by.
       * boundaries: An array of the lower boundaries for each bucket.
       * default: The bucket name for documents that do not fall within the specified boundaries
       * output: {
       *    outputN: Optional. The output object may contain a single or numerous field names used to accumulate values per bucket.
       * }
       */
      $bucket: {
        groupBy: "$dob.age",
        boundaries: [ 0, 18, 30, 40, 50, 60, 120],
        
        output: {
           totalPersons: {$sum: 1},
           avgAge: {$avg: "$dob.age"}}
        }
    }
  ])

  //WE CAN ALSO USE $bucketAuto - with this mongodb generates the buckets 
  //specify by expressions how the data will be grouped 
  //the number of buckets 
  //Mongo check the data and try to distribute the data 
  //in the required number of buckets - distributed equally or the must closed to that
  use('personsAnalytics')
  db.personsData.aggregate([
    {
      /**
       * groupBy: The expression to group by.
       * buckets: The desired number of buckets
       * output: {
       *    outputN: Optional. The output object may contain a single or numerous field names used to accumulate values per bucket.
       * }
       * granularity: Optional number series
       */
      $bucketAuto: {
        groupBy: "$dob.age",
        buckets: 5,
        output: {
          totalPersons: {$sum: 1},
          avgAge: {$avg: "$dob.age"}
        }
      }
    }
  ])

  //get the top 10 oldest people in the dataset 
  use("personsAnalytics") 
  db.personsData.findOne()

  use("personsAnalytics") 
  db.personsData.aggregate([
    {
      $project: {
        _id: 0,
        name: {
          $concat: ["$name.first", " ", "$name.last"]
        },
        birthDate: {
          $toDate: "$dob.date"
        }

      }
    },
    {
      $sort: {birthDate: 1}
    },
    {
      $limit: 10
    }
  ])

  //the same but skip the first 10 oldest 
  use("personsAnalytics") 
  db.personsData.aggregate([
    {
      $project: {
        _id: 0,
        name: {
          $concat: ["$name.first", " ", "$name.last"]
        },
        birthDate: {
          $toDate: "$dob.date"
        }

      }
    },
    {
      $sort: {birthDate: 1}
    },
    {
      /**
       * Provide the number of documents to skip.
       */
      $skip: 10
    }
    {
      $limit: 10
    }
  ])

  //for optimization purposes - the order of the stages matter 
  //if we filter (match) after project or sort - is not optimal
  //mongo perform some optimizaions, processing the stages in the most optimal way
  //if we match first for example is not a suboptimal setup - 
  //because in that way we process a small subset of documents 
  //mongo order the stages in way that is more optimal as possible 
  //but is recomended to optimize the pipeline to avoid possible performance issues

  //optimization - aggregation pipeline 
//mongo sort in optimal way this one 
//with explain - shows that first perform the match stage
use("personsAnalytics") 
  db.personsData.explain().aggregate([
    {
      $project: {
        _id: 0,
        name: {
          $concat: ["$name.first", " ", "$name.last"]
        },
        birthDate: {
          $toDate: "$dob.date"
        },
        gender: 1

      }
    },
    {
      $sort: {birthDate: 1}
    },
    {
      $match: {
        gender: "male"
      }
    },

    {
      $skip: 10
    },
    {
      $limit: 10
    }
  ])
  
//the right order of the stages: 

use("personsAnalytics") 
  db.personsData.explain().aggregate([
    {
      $match: {
        gender: "male"
      }
    },
    {
      $project: {
        _id: 0,
        name: {
          $concat: ["$name.first", " ", "$name.last"]
        },
        birthDate: {
          $toDate: "$dob.date"
        }
      }
    },
    {
      $sort: {birthDate: 1}
    },
    {
      $skip: 10
    },
    {
      $limit: 10
    }
  ])
  
  //projection optimization
  //reducing the amount of data passing through the pipeline
  //pass to next stages only the data that is needed 
  
  ////////////////////////////////////////////////////////
use('test')
db.artists.insertMany([
  { "_id" : 1, "last_name" : "Bernard", "first_name" : "Emil", "year_born" : 1868, "year_died" : 1941, "nationality" : "France" },
  { "_id" : 2, "last_name" : "Rippl-Ronai", "first_name" : "Joszef", "year_born" : 1861, "year_died" : 1927, "nationality" : "Hungary" },
  { "_id" : 3, "last_name" : "Ostroumova", "first_name" : "Anna", "year_born" : 1871, "year_died" : 1955, "nationality" : "Russia" },
  { "_id" : 4, "last_name" : "Van Gogh", "first_name" : "Vincent", "year_born" : 1853, "year_died" : 1890, "nationality" : "Holland" },
  { "_id" : 5, "last_name" : "Maurer", "first_name" : "Alfred", "year_born" : 1868, "year_died" : 1932, "nationality" : "USA" },
  { "_id" : 6, "last_name" : "Munch", "first_name" : "Edvard", "year_born" : 1863, "year_died" : 1944, "nationality" : "Norway" },
  { "_id" : 7, "last_name" : "Redon", "first_name" : "Odilon", "year_born" : 1840, "year_died" : 1916, "nationality" : "France" },
  { "_id" : 8, "last_name" : "Diriks", "first_name" : "Edvard", "year_born" : 1855, "year_died" : 1930, "nationality" : "Norway" }
])

use('test')
db.artists.find()


//The following operation groups the documents into buckets according to the 
//year_born field and filters based on the count of documents in the buckets:
use('test')
db.artists.aggregate([
  {
    $bucket: {
      groupBy: "$year_born",
      boundaries: [ 1840, 1850, 1860, 1870, 1880],
      default: "other", //in case that some document do not fit in any bucket
      output: {
         "count": {$sum: 1},
         "artists": {
          $push: {
            name: {
              $concat: ["$first_name", " ", "$last_name"]            
            },
            year_born: "$year_born" 
          }
         }
      }
    }
  }
  ])

use('test')
db.artists.aggregate([
  {
    $bucket: {
      groupBy: "$year_born",
      boundaries: [ 1840, 1850, 1860, 1870],
      default: "other", //in case that some document do not fit in any bucket
      output: {
         "count": {$sum: 1},
         "artists": {
          $push: {
            name: {
              $concat: ["$first_name", " ", "$last_name"]            
            },
            year_born: "$year_born" 
          }
         }
      }
    }
  },
  {
    $match: {
      count: {$gt: 3}
    }
  }
])

//$facet to perfermo multiple $buckets in one stage


db.artwork.insertMany([
  { "_id" : 1, "title" : "The Pillars of Society", "artist" : "Grosz", "year" : 1926,
      "price" : NumberDecimal("199.99") },
  { "_id" : 2, "title" : "Melancholy III", "artist" : "Munch", "year" : 1902,
      "price" : NumberDecimal("280.00") },
  { "_id" : 3, "title" : "Dancer", "artist" : "Miro", "year" : 1925,
      "price" : NumberDecimal("76.04") },
  { "_id" : 4, "title" : "The Great Wave off Kanagawa", "artist" : "Hokusai",
      "price" : NumberDecimal("167.30") },
  { "_id" : 5, "title" : "The Persistence of Memory", "artist" : "Dali", "year" : 1931,
      "price" : NumberDecimal("483.00") },
  { "_id" : 6, "title" : "Composition VII", "artist" : "Kandinsky", "year" : 1913,
      "price" : NumberDecimal("385.00") },
  { "_id" : 7, "title" : "The Scream", "artist" : "Munch", "year" : 1893
      /* No price*/ },
  { "_id" : 8, "title" : "Blue Flower", "artist" : "O'Keefe", "year" : 1918,
      "price" : NumberDecimal("118.42") }
])


//$facet allows to perform multiple stages in one stage on the same set of input documents
//process multiple aggregation pipelines 
//sub-pipelines
//the output - is an array of documents where each sub-pipeline constains its own fields  
use('test')
db.artwork.findOne()


use('test')
db.artwork.aggregate([
  {
    /**
     * outputFieldN: The first output field.
     * stageN: The first aggregation stage.
     */
    $facet: {
     price:[
      {
        $bucket: {
          groupBy: "$price",
          boundaries: [0, 200, 400],
          default: "other",
          output: {
             count: {$sum: 1},
             artwork: {
              $push: {
                title: "$title",
                artist: "$artist",
                price: "$price"
              }
             },
             avgPrice: {$avg: "$price"}
          }
        }
      }
     ],
     year: [
      {
        $bucket: {
          groupBy: "$year",
          boundaries: [1890, 1910, 1920, 1940],
          default: "Unknown",
          output: {
            count: {$sum: 1},
            artist: {
              $push: {
                title: "$title",
                artist: "$artist",
                year: "$year"
              }
            }
           }
        }
      }
      ]
    }
  }
])


//STORE THE RESULT OF AN AGGREGATION PIPELINE INTO A COLLECTION 
//

use('personsAnalytics')
db.personsData.findOne()

//to write the result of a pipeline into a collection use $out stage
//we add a final stage to save the result into a collection called transformedPersons
//we do this to use a index on location fields 
//to take advantage of the index - geospatial data
use('personsAnalytics')
db.personsData.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      email: 1,
      age: "$dob.age",
      birthdate: {$toDate: "$dob.date"},  
      location: {
        type: "Point", coordinates: [
          {$convert: {
            input: "$location.coordinates.longitude",
            to: "double",
            onError: 0,
            onNull: 0,
          }},
          {
            $convert: {
              input: "$location.coordinates.latitude",
              to: "double",
              onError: 0,
              onNull: 0,
            }
          }
        ]
      }
    }
  },
  {
    $project: {
      fullName:{
        $concat: [
          {$toUpper: {$substrCP: ["$name.first", 0, 1]}},
          {$substrCP: ["$name.first", 1, {$subtract: [{$strLenCP: "$name.first"}, 1]}]},
          " ",
          {$toUpper: {$substrCP: ["$name.last", 0, 1]}},
          {$substrCP: ["$name.last", 1, {$subtract: [{$strLenCP: "$name.last"}, 1]}]}
        ]
      },
      age: 1,
      birthdate: 1,
      location: 1,
      email: 1
    }
  },
  {
    $out: "transformedPersons" 
  }
])

//geonear stage
//used to find documents in our collections that are closed to our 
//current position
//geojson object - point 
//$geonear have to be the first stage to take advantages of indexes on locations
//later we can use any other stages as needed 

//first create a neo index - 2dsphere index
use("personsAnalytics")
db.transformedPersons.createIndex({location: "2dsphere"})

//check the index
use("personsAnalytics")
db.transformedPersons.getIndexes()

//geolocation query and geolocation or geospatial pipeline
//geonear to find all documents that are closed to the current positon 
//refered to the near parameter in the neogear stage 
//based on the distanceField, maxdistance and query
//near parameter is a NeoJson object - type - point and respective coordinates
//num allow to limit the number of documents - is better that use an stage - depricated
//in that way we can fetch the number of documents instead of get all
//query: limited to the documents that match the query and use the index 
//only the first stage can take advantage of indexes and avoid the required 
//use of a match stage con filter out documents from the pipeline
use("personsAnalytics")
db.transformedPersons.aggregate([
  {
    /**
     * near: The point to search near.
     * distanceField: The calculated distance.
     * maxDistance: The maximum distance, in meters, documents can be before being excluded from results.
     * query: Limits results that match the query
     * includeLocs: Optional. Labels and includes the point used to match the document.
     * num: Optional. The maximum number of documents to return.
     * spherical: Defaults to false. Specifies whether to use spherical geometry.
     */
    $geoNear: {
      near: { type: 'Point', coordinates: [-18.5, -42.6] },
      distanceField: 'distance',
      maxDistance: 100000, //meters
      query: {age: {$gt: 30}}
    }
  }

])
//